name: PR Status Gate

# Single scheduled workflow that handles ALL PR status and AC review logic
# Benefits: No race conditions, fork-friendly, self-healing, no flip-flop
on:
  schedule:
    - cron: '*/5 * * * *'  # Every 5 minutes

  # Also run on workflow_run for faster CI status updates (optional optimization)
  workflow_run:
    workflows: [CI, Lint, Quality Security]
    types: [completed]

concurrency:
  # Use PR number for workflow_run, run_id for schedule (each schedule run is independent)
  group: pr-status-gate-${{ github.event.workflow_run.pull_requests[0].number || github.run_id }}
  cancel-in-progress: true  # Cancel previous runs for same PR to prevent flip-flop

permissions:
  pull-requests: write
  checks: read

env:
  REQUIRED_CHECKS: |
    CI / test-frontend
    CI / test-python (3.12)
    CI / test-python (3.13)
    Lint / python
    Quality Security / CodeQL (javascript-typescript)
    Quality Security / CodeQL (python)
    Quality Security / Python Security (Bandit)
    Quality Security / Security Summary

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # SINGLE JOB: Process all open PRs (SCHEDULED ONLY)
  # Handles: CI status, AC labels (3-min, 30-min), review detection, re-review
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  process-prs:
    name: Process Open PRs
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    timeout-minutes: 10

    steps:
      - name: Process all open PRs
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: ${{ env.REQUIRED_CHECKS }}
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // CONFIGURATION
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            const CONFIG = {
              // Timing thresholds (minutes)
              MISSING_APPROVAL_DELAY: 3,    // Add "Missing AC Approval" after 3 min
              AUTO_CHECK_DELAY: 30,         // Post auto status report after 30 min
              AUTO_CHECK_WINDOW: 35,        // Don't re-post if older than 35 min
              RECENT_COMMENT_WINDOW: 10,    // @AutoClaudeCheck within last 10 min
              
              // Labels
              STATUS_LABELS: Object.freeze({
                CHECKING: 'üîÑ Checking',
                PASSED: '‚úÖ Ready for Review',
                FAILED: '‚ùå Checks Failed'
              }),
              
              REVIEW_LABELS: Object.freeze([
                'Missing AC Approval',
                'AC: Approved',
                'AC: Changes Requested',
                'AC: Blocked',
                'AC: Needs Re-review'
              ]),
              
              // Auto Claude detection
              AC_PATTERNS: Object.freeze([
                'ü§ñ Auto Claude PR Review',
                'Auto Claude Review',
                'Auto-Claude Review'
              ]),
              
              AC_VERDICTS: Object.freeze({
                APPROVED: {
                  patterns: ['Auto Claude Review - APPROVED', '‚úÖ Auto Claude Review - APPROVED'],
                  regex: /Merge Verdict:\s*‚úÖ\s*(?:APPROVED|READY TO MERGE)/i,
                  label: 'AC: Approved'
                },
                CHANGES_REQUESTED: {
                  patterns: ['NEEDS REVISION', 'Needs Revision'],
                  regex: /Merge Verdict:\s*üü†/,
                  label: 'AC: Changes Requested'
                },
                BLOCKED: {
                  patterns: ['BLOCKED'],
                  regex: /Merge Verdict:\s*üî¥/,
                  label: 'AC: Blocked'
                }
              }),
              
              // Trusted sources for AC reviews
              TRUSTED_BOTS: ['github-actions[bot]', 'auto-claude[bot]'],
              TRUSTED_ASSOCIATIONS: ['COLLABORATOR', 'MEMBER', 'OWNER']
            };
            
            const REQUIRED_CHECKS = process.env.REQUIRED_CHECKS
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // HELPER FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            const { owner, repo } = context.repo;
            
            function getAgeMinutes(dateStr) {
              return (Date.now() - new Date(dateStr).getTime()) / 60000;
            }
            
            function hasLabel(labels, name) {
              return labels.some(l => l.name === name);
            }
            
            function hasAnyACLabel(labels) {
              return CONFIG.REVIEW_LABELS.some(l => hasLabel(labels, l));
            }
            
            async function addLabelIfMissing(prNumber, labels, labelName) {
              if (hasLabel(labels, labelName)) return false;
              try {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: prNumber, labels: [labelName]
                });
                console.log(`    ‚úì Added: ${labelName}`);
                return true;
              } catch (e) {
                if (e.status !== 404) console.log(`    ‚ö† Failed to add ${labelName}: ${e.message}`);
                return false;
              }
            }
            
            async function removeLabelIfPresent(prNumber, labels, labelName) {
              if (!hasLabel(labels, labelName)) return false;
              try {
                await github.rest.issues.removeLabel({
                  owner, repo, issue_number: prNumber, name: labelName
                });
                console.log(`    ‚úì Removed: ${labelName}`);
                return true;
              } catch (e) {
                if (e.status !== 404) console.log(`    ‚ö† Failed to remove ${labelName}: ${e.message}`);
                return false;
              }
            }
            
            async function setStatusLabel(prNumber, labels, newLabel) {
              const currentStatus = Object.values(CONFIG.STATUS_LABELS).find(l => hasLabel(labels, l));
              if (currentStatus === newLabel) return; // Already correct
              
              // Remove other status labels
              for (const label of Object.values(CONFIG.STATUS_LABELS)) {
                if (label !== newLabel) await removeLabelIfPresent(prNumber, labels, label);
              }
              await addLabelIfMissing(prNumber, labels, newLabel);
            }
            
            async function setReviewLabel(prNumber, labels, newLabel) {
              // Remove all other review labels
              for (const label of CONFIG.REVIEW_LABELS) {
                if (label !== newLabel) await removeLabelIfPresent(prNumber, labels, label);
              }
              await addLabelIfMissing(prNumber, labels, newLabel);
            }
            
            async function fetchCheckRuns(sha) {
              const checkRuns = await github.paginate(
                github.rest.checks.listForRef,
                { owner, repo, ref: sha, per_page: 100 },
                (response) => response.data
              );
              return checkRuns;
            }
            
            function analyzeChecks(checkRuns) {
              let allComplete = true;
              let anyFailed = false;
              let passedCount = 0;
              
              for (const checkName of REQUIRED_CHECKS) {
                const check = checkRuns.find(c => c.name === checkName);
                if (!check || check.status !== 'completed') {
                  allComplete = false;
                } else if (check.conclusion === 'success' || check.conclusion === 'skipped') {
                  passedCount++;
                } else {
                  anyFailed = true;
                }
              }
              return { allComplete, anyFailed, passedCount };
            }
            
            function parseACVerdict(body) {
              if (!body) return null;
              const safeBody = body.slice(0, 5000);
              
              // Check if it's an AC comment first
              const isACComment = CONFIG.AC_PATTERNS.some(p => safeBody.includes(p));
              if (!isACComment) return null;
              
              for (const [key, config] of Object.entries(CONFIG.AC_VERDICTS)) {
                const patternMatch = config.patterns.some(p => safeBody.includes(p));
                const regexMatch = config.regex && config.regex.test(safeBody);
                if (patternMatch || regexMatch) {
                  return { verdict: key, label: config.label };
                }
              }
              return null;
            }
            
            function isTrustedSource(comment) {
              const username = comment.user.login;
              const userType = comment.user.type;
              const assoc = comment.author_association;
              
              const isBot = CONFIG.TRUSTED_BOTS.some(b => 
                username.toLowerCase() === b.toLowerCase()
              ) && userType === 'Bot';
              
              const isCollaborator = CONFIG.TRUSTED_ASSOCIATIONS.includes(assoc);
              
              return isBot || isCollaborator;
            }
            
            async function postStatusReport(prNumber, pr, checkRuns, triggeredBy) {
              const { allComplete, anyFailed, passedCount } = analyzeChecks(checkRuns);
              
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: prNumber
              });
              const currentReviewLabel = CONFIG.REVIEW_LABELS.find(l => hasLabel(labels, l)) || 'None';
              
              let statusEmoji = 'üîÑ';
              let statusLabel = CONFIG.STATUS_LABELS.CHECKING;
              if (allComplete && !anyFailed) {
                statusEmoji = '‚úÖ';
                statusLabel = CONFIG.STATUS_LABELS.PASSED;
              } else if (allComplete && anyFailed) {
                statusEmoji = '‚ùå';
                statusLabel = CONFIG.STATUS_LABELS.FAILED;
              }
              
              const lines = [
                `## ${statusEmoji} PR Status Report`,
                '',
                `| Label | Value |`,
                `|-------|-------|`,
                `| CI Status | ${statusLabel} |`,
                `| AC Review | ${currentReviewLabel} |`,
                '',
                `### CI Checks (${passedCount}/${REQUIRED_CHECKS.length} passed)`,
                '',
                '| Status | Check |',
                '|--------|-------|'
              ];
              
              for (const checkName of REQUIRED_CHECKS) {
                const check = checkRuns.find(c => c.name === checkName);
                let emoji = '‚è≥';
                if (check) {
                  if (check.status !== 'completed') emoji = 'üîÑ';
                  else if (check.conclusion === 'success') emoji = '‚úÖ';
                  else if (check.conclusion === 'skipped') emoji = '‚è≠Ô∏è';
                  else emoji = '‚ùå';
                }
                lines.push(`| ${emoji} | ${checkName} |`);
              }
              
              lines.push('');
              lines.push('---');
              lines.push(`<sub>${triggeredBy}</sub>`);
              
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber, body: lines.join('\n')
              });
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // MAIN LOGIC
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            console.log('::group::Fetching open PRs');
            
            // Get all open PRs
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open', sort: 'created', direction: 'desc', per_page: 100
            });
            
            console.log(`Found ${prs.length} open PR(s)`);
            console.log('::endgroup::');
            
            if (prs.length === 0) {
              console.log('No open PRs to process');
              return;
            }
            
            // Process each PR
            for (const pr of prs) {
              const prNumber = pr.number;
              const ageMinutes = getAgeMinutes(pr.created_at);
              const headSha = pr.head.sha;
              
              console.log(`::group::PR #${prNumber} (age: ${Math.floor(ageMinutes)} min)`);
              
              // Get current labels
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: prNumber
              });
              
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              // 1. UPDATE CI STATUS
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              console.log('  [1] Checking CI status...');
              const checkRuns = await fetchCheckRuns(headSha);
              const { allComplete, anyFailed } = analyzeChecks(checkRuns);
              
              if (allComplete) {
                const newStatus = anyFailed ? CONFIG.STATUS_LABELS.FAILED : CONFIG.STATUS_LABELS.PASSED;
                await setStatusLabel(prNumber, labels, newStatus);
              } else {
                await setStatusLabel(prNumber, labels, CONFIG.STATUS_LABELS.CHECKING);
              }
              
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              // 2. ADD "Missing AC Approval" AFTER 3 MINUTES
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              if (ageMinutes >= CONFIG.MISSING_APPROVAL_DELAY && !hasAnyACLabel(labels)) {
                console.log('  [2] PR is 3+ min old with no AC label...');
                await addLabelIfMissing(prNumber, labels, 'Missing AC Approval');
              }
              
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              // 3. SCAN COMMENTS FOR AUTO CLAUDE VERDICT
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              console.log('  [3] Scanning for Auto Claude verdicts...');
              const { data: comments } = await github.rest.issues.listComments({
                owner, repo, issue_number: prNumber, per_page: 50
              });
              
              // Find most recent AC verdict from trusted source
              let latestVerdict = null;
              let latestVerdictTime = 0;
              
              for (const comment of comments) {
                if (!isTrustedSource(comment)) continue;
                const verdict = parseACVerdict(comment.body);
                if (verdict) {
                  const commentTime = new Date(comment.created_at).getTime();
                  if (commentTime > latestVerdictTime) {
                    latestVerdict = verdict;
                    latestVerdictTime = commentTime;
                  }
                }
              }
              
              if (latestVerdict) {
                const currentACLabel = CONFIG.REVIEW_LABELS.find(l => hasLabel(labels, l));
                if (currentACLabel !== latestVerdict.label) {
                  console.log(`    Found verdict: ${latestVerdict.verdict}`);
                  await setReviewLabel(prNumber, labels, latestVerdict.label);
                }
              }
              
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              // 4. CHECK FOR @AutoClaudeCheck COMMAND (recent comments)
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              console.log('  [4] Checking for @AutoClaudeCheck command...');
              const recentAutoCheck = comments.find(c => {
                const age = getAgeMinutes(c.created_at);
                return age <= CONFIG.RECENT_COMMENT_WINDOW && 
                       c.body && c.body.includes('@AutoClaudeCheck');
              });
              
              if (recentAutoCheck) {
                // Check if we already responded (look for our status report)
                const alreadyResponded = comments.some(c => {
                  const cAge = getAgeMinutes(c.created_at);
                  return cAge < getAgeMinutes(recentAutoCheck.created_at) - 0.1 && // After the command
                         c.body && c.body.includes('## ') && c.body.includes('PR Status Report');
                });
                
                if (!alreadyResponded) {
                  console.log(`    Responding to @AutoClaudeCheck from @${recentAutoCheck.user.login}`);
                  await postStatusReport(prNumber, pr, checkRuns, 
                    `Triggered by \`@AutoClaudeCheck\` from @${recentAutoCheck.user.login}`);
                }
              }
              
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              // 5. AUTO STATUS REPORT AT 30 MINUTES
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              if (ageMinutes >= CONFIG.AUTO_CHECK_DELAY && 
                  ageMinutes < CONFIG.AUTO_CHECK_WINDOW &&
                  hasLabel(labels, 'Missing AC Approval')) {
                
                // Check if we already posted auto report
                const hasAutoReport = comments.some(c => 
                  c.body && c.body.includes('Auto status check (30 min)')
                );
                
                if (!hasAutoReport) {
                  console.log('  [5] Posting 30-min auto status report...');
                  await postStatusReport(prNumber, pr, checkRuns, 
                    'ü§ñ Auto status check (30 min) - PR still missing AC approval');
                }
              }
              
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              // 6. CHECK FOR NEW COMMITS AFTER APPROVAL
              // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              if (hasLabel(labels, 'AC: Approved')) {
                console.log('  [6] Checking for commits after approval...');
                
                // Find the approval comment time
                let approvalTime = 0;
                for (const comment of comments) {
                  if (!isTrustedSource(comment)) continue;
                  const verdict = parseACVerdict(comment.body);
                  if (verdict && verdict.label === 'AC: Approved') {
                    const t = new Date(comment.created_at).getTime();
                    if (t > approvalTime) approvalTime = t;
                  }
                }
                
                if (approvalTime > 0) {
                  // Get commits and check if any are newer than approval
                  const { data: commits } = await github.rest.pulls.listCommits({
                    owner, repo, pull_number: prNumber, per_page: 10
                  });
                  
                  const newCommits = commits.filter(c => {
                    const commitTime = new Date(c.commit.committer.date).getTime();
                    return commitTime > approvalTime;
                  });
                  
                  if (newCommits.length > 0) {
                    console.log(`    Found ${newCommits.length} commit(s) after approval, resetting...`);
                    await setReviewLabel(prNumber, labels, 'AC: Needs Re-review');
                    
                    // Post notification
                    const notifyLines = [
                      '## üîÑ Re-review Required',
                      '',
                      'New commits were pushed after Auto-Claude approval.',
                      '',
                      '| Previous | Current |',
                      '|----------|---------|',
                      '| `AC: Approved` | `AC: Needs Re-review` |',
                      '',
                      'Please run Auto-Claude review again or request a manual review.'
                    ];
                    
                    await github.rest.issues.createComment({
                      owner, repo, issue_number: prNumber, body: notifyLines.join('\n')
                    });
                  }
                }
              }
              
              console.log('::endgroup::');
            }
            
            console.log(`‚úÖ Processed ${prs.length} PR(s)`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # FAST CI UPDATE (optional - triggered by workflow_run for quicker feedback)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  fast-ci-update:
    name: Fast CI Update
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.pull_requests[0] != null
    timeout-minutes: 5

    steps:
      - name: Update CI status label
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: ${{ env.REQUIRED_CHECKS }}
        with:
          retries: 3
          script: |
            const STATUS_LABELS = {
              CHECKING: 'üîÑ Checking',
              PASSED: '‚úÖ Ready for Review',
              FAILED: '‚ùå Checks Failed'
            };
            
            const REQUIRED_CHECKS = process.env.REQUIRED_CHECKS
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);
            
            const { owner, repo } = context.repo;
            const prNumber = context.payload.workflow_run.pull_requests[0].number;
            const headSha = context.payload.workflow_run.head_sha;
            
            console.log(`PR #${prNumber} - Fast CI update, SHA: ${headSha.slice(0, 8)}`);
            
            // Fetch check runs
            const checkRuns = await github.paginate(
              github.rest.checks.listForRef,
              { owner, repo, ref: headSha, per_page: 100 },
              (response) => response.data
            );
            
            // Analyze
            let allComplete = true;
            let anyFailed = false;
            
            for (const checkName of REQUIRED_CHECKS) {
              const check = checkRuns.find(c => c.name === checkName);
              if (!check || check.status !== 'completed') {
                allComplete = false;
              } else if (check.conclusion !== 'success' && check.conclusion !== 'skipped') {
                anyFailed = true;
              }
            }
            
            // Get current labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);
            
            // Determine new label
            let newLabel = STATUS_LABELS.CHECKING;
            if (allComplete) {
              newLabel = anyFailed ? STATUS_LABELS.FAILED : STATUS_LABELS.PASSED;
            }
            
            // Skip if already correct
            if (labelNames.includes(newLabel)) {
              console.log(`Label '${newLabel}' already set`);
              return;
            }
            
            // Update labels
            for (const label of Object.values(STATUS_LABELS)) {
              if (labelNames.includes(label)) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                } catch (e) { /* ignore */ }
              }
            }
            
            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newLabel] });
            console.log(`‚úÖ Updated to: ${newLabel}`);
