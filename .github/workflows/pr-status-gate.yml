name: PR Status Gate

on:
  workflow_run:
    workflows: [CI, Lint, Quality Security]
    types: [completed]

  issue_comment:
    types: [created, edited]

  # Using pull_request_target to support fork PRs with write permissions
  # SECURITY: This is safe because we only read PR metadata and don't checkout/execute PR code
  pull_request_target:
    types: [synchronize]

concurrency:
  group: pr-status-gate-${{ github.event.workflow_run.pull_requests[0].number || github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  checks: read

env:
  # Shared configuration - single source of truth
  REQUIRED_CHECKS: |
    CI / test-frontend
    CI / test-python (3.12)
    CI / test-python (3.13)
    Lint / python
    Quality Security / CodeQL (javascript-typescript)
    Quality Security / CodeQL (python)
    Quality Security / Python Security (Bandit)
    Quality Security / Security Summary

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: CI STATUS (triggered by workflow_run)
  # Updates CI status labels when monitored workflows complete
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-ci-status:
    name: Update CI Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.pull_requests[0] != null
    timeout-minutes: 5

    steps:
      - name: Check all required checks and update label
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: ${{ env.REQUIRED_CHECKS }}
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            // NOTE: STATUS_LABELS is intentionally duplicated across jobs.
            // GitHub Actions jobs run in isolated contexts and cannot share runtime constants.
            // If label values change, update ALL occurrences: update-ci-status, check-status-command
            const STATUS_LABELS = Object.freeze({
              CHECKING: 'ðŸ”„ Checking',
              PASSED: 'âœ… Ready for Review',
              FAILED: 'âŒ Checks Failed'
            });

            const REQUIRED_CHECKS = process.env.REQUIRED_CHECKS
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);

            async function fetchCheckRuns(sha) {
              const { owner, repo } = context.repo;
              // Let the configured retries (retries: 3) handle transient failures
              // Don't catch errors - allow them to propagate for retry logic
              const checkRuns = await github.paginate(
                github.rest.checks.listForRef,
                { owner, repo, ref: sha, per_page: 100 },
                (response) => response.data
              );
              return checkRuns;
            }

            function analyzeChecks(checkRuns) {
              const results = [];
              let allComplete = true;
              let anyFailed = false;

              for (const checkName of REQUIRED_CHECKS) {
                const check = checkRuns.find(c => c.name === checkName);

                if (!check) {
                  results.push({ name: checkName, status: 'â³ Pending', complete: false });
                  allComplete = false;
                } else if (check.status !== 'completed') {
                  results.push({ name: checkName, status: 'ðŸ”„ Running', complete: false });
                  allComplete = false;
                } else if (check.conclusion === 'success') {
                  results.push({ name: checkName, status: 'âœ… Passed', complete: true });
                } else if (check.conclusion === 'skipped') {
                  results.push({ name: checkName, status: 'â­ï¸ Skipped', complete: true, skipped: true });
                } else {
                  results.push({ name: checkName, status: 'âŒ Failed', complete: true, failed: true });
                  anyFailed = true;
                }
              }
              return { allComplete, anyFailed, results };
            }

            async function updateStatusLabels(prNumber, newLabel) {
              const { owner, repo } = context.repo;
              const allLabels = Object.values(STATUS_LABELS);

              // Check current labels to avoid unnecessary remove/add cycles (prevents flip-flop)
              const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: prNumber
              });
              const currentLabelNames = currentLabels.map(l => l.name);
              const hasNewLabel = currentLabelNames.includes(newLabel);
              const otherStatusLabels = allLabels.filter(l => l !== newLabel && currentLabelNames.includes(l));

              // Skip if already has correct label and no other status labels
              if (hasNewLabel && otherStatusLabels.length === 0) {
                console.log(`  Label '${newLabel}' already set, skipping update`);
                return;
              }

              // Only remove other status labels (not the one we're adding)
              for (const label of otherStatusLabels) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                  console.log(`  Removed: ${label}`);
                } catch (e) {
                  if (e && e.status !== 404) {
                    throw new Error(`Failed to remove label '${label}': ${e.message}`);
                  }
                }
              }

              // Only add if not already present
              if (!hasNewLabel) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newLabel] });
                  console.log(`  Added: ${newLabel}`);
                } catch (e) {
                  if (e && e.status === 404) {
                    core.warning(`Label '${newLabel}' does not exist`);
                  } else {
                    throw e;
                  }
                }
              }
            }

            // Main logic
            const prNumber = context.payload.workflow_run.pull_requests[0].number;
            const headSha = context.payload.workflow_run.head_sha;
            const triggerWorkflow = context.payload.workflow_run.name;

            console.log(`PR #${prNumber} - Triggered by: ${triggerWorkflow}, SHA: ${headSha.slice(0, 8)}`);

            const checkRuns = await fetchCheckRuns(headSha);
            console.log(`Found ${checkRuns.length} check runs`);
            const { allComplete, anyFailed, results } = analyzeChecks(checkRuns);

            for (const r of results) {
              console.log(`  ${r.status} ${r.name}`);
            }

            if (!allComplete) {
              const pending = results.filter(r => !r.complete).length;
              console.log(`â³ ${pending}/${REQUIRED_CHECKS.length} checks pending`);
              // Update to CHECKING status if checks are still running (prevents stale Ready/Failed status)
              await updateStatusLabels(prNumber, STATUS_LABELS.CHECKING);
              return;
            }

            const newLabel = anyFailed ? STATUS_LABELS.FAILED : STATUS_LABELS.PASSED;
            await updateStatusLabels(prNumber, newLabel);

            const passedCount = results.filter(r => r.status === 'âœ… Passed').length;
            const failedCount = results.filter(r => r.failed).length;

            if (anyFailed) {
              console.log(`âŒ PR #${prNumber}: ${failedCount} check(s) failed`);
            } else {
              console.log(`âœ… PR #${prNumber}: Ready for review (${passedCount}/${REQUIRED_CHECKS.length} passed)`);
            }

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: /check-status COMMAND
  # Manual status check - anyone can trigger by commenting /check-status
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  check-status-command:
    name: Check Status Command
    runs-on: ubuntu-latest
    # Trigger on /check-status OR @AutoClaudeCheck comment on PRs
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      (contains(github.event.comment.body, '/check-status') ||
       contains(github.event.comment.body, '@AutoClaudeCheck'))
    timeout-minutes: 5

    steps:
      - name: Run status check and post report
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: ${{ env.REQUIRED_CHECKS }}
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            // NOTE: STATUS_LABELS is intentionally duplicated across jobs.
            // GitHub Actions jobs run in isolated contexts and cannot share runtime constants.
            // If label values change, update ALL occurrences: update-ci-status, check-status-command
            const STATUS_LABELS = Object.freeze({
              CHECKING: 'ðŸ”„ Checking',
              PASSED: 'âœ… Ready for Review',
              FAILED: 'âŒ Checks Failed'
            });

            // NOTE: REVIEW_LABELS is intentionally duplicated across jobs.
            // If label values change, update ALL occurrences: check-status-command, update-review-status
            const REVIEW_LABELS = Object.freeze([
              'Missing AC Approval',
              'AC: Approved',
              'AC: Changes Requested',
              'AC: Blocked',
              'AC: Needs Re-review',
              'AC: Reviewed'
            ]);

            const REQUIRED_CHECKS = process.env.REQUIRED_CHECKS
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);

            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const requestedBy = context.payload.comment.user.login;

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner, repo, pull_number: prNumber
            });
            const headSha = pr.head.sha;

            console.log(`PR #${prNumber} - /check-status by @${requestedBy}, SHA: ${headSha.slice(0, 8)}`);

            // Fetch check runs with pagination to handle >100 checks
            const checkRuns = await github.paginate(
              github.rest.checks.listForRef,
              { owner, repo, ref: headSha, per_page: 100 },
              (response) => response.data
            );
            console.log(`Found ${checkRuns.length} check runs`);

            // Analyze results
            const results = [];
            let allComplete = true;
            let anyFailed = false;

            for (const checkName of REQUIRED_CHECKS) {
              const check = checkRuns.find(c => c.name === checkName);

              if (!check) {
                results.push({ name: checkName, emoji: 'â³', complete: false });
                allComplete = false;
              } else if (check.status !== 'completed') {
                results.push({ name: checkName, emoji: 'ðŸ”„', complete: false });
                allComplete = false;
              } else if (check.conclusion === 'success') {
                results.push({ name: checkName, emoji: 'âœ…', complete: true });
              } else if (check.conclusion === 'skipped') {
                results.push({ name: checkName, emoji: 'â­ï¸', complete: true, skipped: true });
              } else {
                results.push({ name: checkName, emoji: 'âŒ', complete: true, failed: true });
                anyFailed = true;
              }
            }

            // Get current labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = currentLabels.map(l => l.name);
            const currentStatusLabel = Object.values(STATUS_LABELS).find(l => labelNames.includes(l)) || 'None';
            const currentReviewLabel = REVIEW_LABELS.find(l => labelNames.includes(l)) || 'None';

            // Update label if all checks complete
            let newStatusLabel = STATUS_LABELS.CHECKING;
            let statusChanged = false;

            if (allComplete) {
              newStatusLabel = anyFailed ? STATUS_LABELS.FAILED : STATUS_LABELS.PASSED;

              if (newStatusLabel !== currentStatusLabel) {
                statusChanged = true;
                // Remove all status labels first - throw on non-404 errors to prevent conflicting labels
                for (const label of Object.values(STATUS_LABELS)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                  } catch (e) {
                    if (e && e.status !== 404) {
                      throw new Error(`Failed to remove label '${label}': ${e.message}`);
                    }
                  }
                }
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newStatusLabel] });
              }
            }

            // Build status report
            const passedCount = results.filter(r => r.emoji === 'âœ…').length;
            let statusEmoji = 'ðŸ”„';
            if (allComplete && !anyFailed) statusEmoji = 'âœ…';
            else if (allComplete && anyFailed) statusEmoji = 'âŒ';

            const checksTable = results.map(r => `| ${r.emoji} | ${r.name} |`).join('\n');

            const lines = [
              `## ${statusEmoji} PR Status Report`,
              '',
              `| Label | Value |`,
              `|-------|-------|`,
              `| CI Status | ${newStatusLabel} |`,
              `| AC Review | ${currentReviewLabel} |`,
              ''
            ];

            if (statusChanged) {
              lines.push(`> Status updated: \`${currentStatusLabel}\` â†’ \`${newStatusLabel}\``);
              lines.push('');
            }

            lines.push(`### CI Checks (${passedCount}/${REQUIRED_CHECKS.length} passed)`);
            lines.push('');
            lines.push('| Status | Check |');
            lines.push('|--------|-------|');
            lines.push(checksTable);
            lines.push('');
            lines.push('---');
            lines.push(`<sub>Triggered by \`/check-status\` from @${requestedBy}</sub>`);

            await github.rest.issues.createComment({
              owner, repo, issue_number: prNumber, body: lines.join('\n')
            });

            console.log(`âœ… Posted status report to PR #${prNumber}`);

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: AUTO-CLAUDE REVIEW
  # Processes Auto-Claude review comments from trusted sources
  # Security: Only bots and collaborators can update labels
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-review-status:
    name: Update Review Status
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      !contains(github.event.comment.body, '/check-status') &&
      !contains(github.event.comment.body, '@AutoClaudeCheck')
    timeout-minutes: 5

    steps:
      - name: Check for Auto-Claude review
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            // Security configuration
            // SECURITY: Only [bot] suffixed accounts are protected by GitHub.
            // Regular usernames can be registered by anyone and are NOT trusted.
            const TRUSTED_BOT_ACCOUNTS = Object.freeze([
              'github-actions[bot]',
              'auto-claude[bot]'
            ]);

            const TRUSTED_AUTHOR_ASSOCIATIONS = Object.freeze([
              'COLLABORATOR',
              'MEMBER',
              'OWNER'
            ]);

            const IDENTIFIER_PATTERNS = Object.freeze([
              'ðŸ¤– Auto Claude PR Review',
              'Auto Claude Review',
              'Auto-Claude Review'
            ]);

            // SECURITY: Regex patterns are tightened to prevent false matches
            // Using \s* instead of .* and requiring specific emoji + verdict format
            const VERDICTS = Object.freeze({
              APPROVED: {
                patterns: ['Auto Claude Review - APPROVED', 'âœ… Auto Claude Review - APPROVED'],
                // Match: "Merge Verdict:" followed by whitespace/emoji, then âœ…, then APPROVED/READY TO MERGE
                regex: /Merge Verdict:\s*âœ…\s*(?:APPROVED|READY TO MERGE)/i,
                label: 'AC: Approved'
              },
              CHANGES_REQUESTED: {
                patterns: ['NEEDS REVISION', 'Needs Revision'],
                // Match: "Merge Verdict:" followed by whitespace/emoji, then ðŸŸ 
                regex: /Merge Verdict:\s*ðŸŸ /,
                label: 'AC: Changes Requested'
              },
              BLOCKED: {
                patterns: ['BLOCKED'],
                // Match: "Merge Verdict:" followed by whitespace/emoji, then ðŸ”´
                regex: /Merge Verdict:\s*ðŸ”´/,
                label: 'AC: Blocked'
              }
            });

            // NOTE: REVIEW_LABELS is intentionally duplicated across jobs.
            // GitHub Actions jobs run in isolated contexts and cannot share runtime constants.
            // If label values change, update ALL occurrences: check-status-command, update-review-status
            const REVIEW_LABELS = Object.freeze([
              'Missing AC Approval',
              'AC: Approved',
              'AC: Changes Requested',
              'AC: Blocked',
              'AC: Needs Re-review',
              'AC: Reviewed'
            ]);

            // Helper functions
            // SECURITY: Verify both username AND account type to prevent spoofing
            function isTrustedBot(username, userType) {
              const isKnownBot = TRUSTED_BOT_ACCOUNTS.some(t => username.toLowerCase() === t.toLowerCase());
              // Only trust if it's a known bot account AND GitHub confirms it's a Bot type
              return isKnownBot && userType === 'Bot';
            }

            function isTrustedAssociation(assoc) {
              return TRUSTED_AUTHOR_ASSOCIATIONS.includes(assoc);
            }

            function isAutoClaudeComment(body) {
              return IDENTIFIER_PATTERNS.some(p => body.includes(p));
            }

            function parseVerdict(body) {
              const safeBody = body.slice(0, 5000);
              for (const [key, config] of Object.entries(VERDICTS)) {
                const patternMatch = config.patterns.some(p => safeBody.includes(p));
                const regexMatch = config.regex && config.regex.test(safeBody);
                if (patternMatch || regexMatch) {
                  return { verdict: key, label: config.label };
                }
              }
              return null;
            }

            async function updateReviewLabels(prNumber, newLabel) {
              const { owner, repo } = context.repo;

              // Remove all review labels first - throw on non-404 errors to prevent conflicting labels
              for (const label of REVIEW_LABELS) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                  console.log(`  Removed: ${label}`);
                } catch (e) {
                  if (e && e.status !== 404) {
                    // Throw to prevent adding new label if removal failed (could cause conflicting labels)
                    throw new Error(`Failed to remove label '${label}': ${e.message}`);
                  }
                }
              }

              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newLabel] });
                console.log(`  Added: ${newLabel}`);
              } catch (e) {
                if (e && e.status === 404) {
                  core.warning(`Label '${newLabel}' does not exist`);
                } else {
                  throw e;
                }
              }
            }

            // Main logic
            const prNumber = context.payload.issue.number;
            const comment = context.payload.comment;
            const commenter = comment.user.login;
            const commenterType = comment.user.type;
            const authorAssociation = comment.author_association;
            const body = comment.body || '';

            console.log(`PR #${prNumber} - Comment by: ${commenter} (type: ${commenterType}, assoc: ${authorAssociation})`);

            // Security checks
            // SECURITY: Bot status requires BOTH username match AND verified Bot type
            const isBot = isTrustedBot(commenter, commenterType);
            const isCollaborator = isTrustedAssociation(authorAssociation);
            const isACComment = isAutoClaudeComment(body);

            console.log(`  Trusted bot: ${isBot}, Collaborator: ${isCollaborator}, AC comment: ${isACComment}`);

            if (!isBot && !isCollaborator) {
              console.log('Skipping: Not a trusted bot or collaborator');
              return;
            }

            if (!isACComment) {
              console.log('Skipping: Not an Auto-Claude comment');
              return;
            }

            const verdictResult = parseVerdict(body);
            if (!verdictResult) {
              console.log('Skipping: Could not parse verdict');
              return;
            }

            console.log(`Verdict: ${verdictResult.verdict} â†’ ${verdictResult.label}`);
            await updateReviewLabels(prNumber, verdictResult.label);
            console.log(`âœ… PR #${prNumber} review status updated`);

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 4: RE-REVIEW ON PUSH
  # When new commits pushed after AC approval, require re-review
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  require-re-review:
    name: Require Re-review on Push
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target' && github.event.action == 'synchronize'
    timeout-minutes: 5

    steps:
      - name: Check and reset AC approval if needed
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const pusher = context.payload.sender.login;

            console.log(`PR #${prNumber} - New commits by: ${pusher}`);

            // Get current labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);

            // Check if PR was approved
            const wasApproved = labelNames.includes('AC: Approved');

            if (!wasApproved) {
              console.log('PR was not AC-approved, no action needed');
              return;
            }

            console.log('PR was AC-approved, resetting to require re-review');

            // Remove AC: Approved - throw on non-404 errors to prevent conflicting labels
            try {
              await github.rest.issues.removeLabel({
                owner, repo, issue_number: prNumber, name: 'AC: Approved'
              });
              console.log('  Removed: AC: Approved');
            } catch (e) {
              if (e && e.status !== 404) {
                // Throw to prevent adding 'AC: Needs Re-review' if removal failed (could cause conflicting labels)
                core.error(`Failed to remove 'AC: Approved' label: ${e.message}`);
                throw e;
              }
            }

            // Add AC: Needs Re-review
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: prNumber, labels: ['AC: Needs Re-review']
              });
              console.log('  Added: AC: Needs Re-review');
            } catch (e) {
              if (e && e.status === 404) {
                core.warning("Label 'AC: Needs Re-review' does not exist");
              } else {
                throw e;
              }
            }

            // Post notification comment
            const commentLines = [
              '## ðŸ”„ Re-review Required',
              '',
              'New commits were pushed after Auto-Claude approval.',
              '',
              '| Previous | Current |',
              '|----------|---------|',
              '| `AC: Approved` | `AC: Needs Re-review` |',
              '',
              'Please run Auto-Claude review again or request a manual review.',
              '',
              '---',
              `<sub>Triggered by push from @${pusher}</sub>`
            ];

            await github.rest.issues.createComment({
              owner, repo, issue_number: prNumber, body: commentLines.join('\n')
            });

            console.log(`âœ… Posted re-review notification to PR #${prNumber}`);
